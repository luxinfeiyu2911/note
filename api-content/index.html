{"posts":[{"title":"Java虚拟机与JVM高级特性","content":"📖 学习书目: 深入理解Java虚拟机 JVM高级特性与最佳实践(第三版 2019出版) 🔖 适读人群: 1. Java技术体系中、高级开发人员; 2. 系统调优师; 3. 系统架构师; 前言-介绍书目 本书共五部分: 走进Java、自动内存管理、虚拟机执行子系统、程序编译与代码优化、高效并发; 各部分之间互相独立,前后没有依赖 部分内的章节存在先后顺序 📜 部分一: 走进Java(第1章) 第1章: 介绍Java技术体系的相关情况,使用的JDK版本为: OpenJDK 12 📜 部分二: 自动内存管理(第2~5章) 第2章: 虚拟机内存划分,哪部分导致内存溢出异常的方式和出现原因 第3章: 垃圾收集算法和HotSpot虚拟机中提供的几款垃圾收集器的特点及运作原理 第4章: 随JDK发布的基础命令行工具与可视化的故障处理工具的使用方法 第5章: 通过实际案例来讲解故障处理和调优 📜 部分三: 虚拟机执行子系统(第6~9章) 第6章: 讲解Class文件结构的各部分组成,每部分的定义、数据结构和使用方法,演示Class的数据如何存储和访问 第7章: 类的加载过程: “加载”,“验证”,“准备”,“解析”和“初始化”,五个阶段中虚拟机分别进行哪些操作,类加载器的工作原理及对虚拟机的意义高效并发 第8章: 虚拟机执行代码时,分析并找到正确的方法和执行方法内的字节码,以及内存结构 第9章: 通过执行子系统的案例,了解使用类加载器和处理字节码的一些思路 📜 部分四: 程序编译与代码优化(第10~11章) 第10章: 分析Java语言中的泛型、主动装箱拆箱、条件编译等多种语法糖,实战如何使用插入式注解处理器来检查程序命名规范的编译器插件 第11章: 虚拟机的热点探测方法、HotSpot的即时编译器、编译触发条件,从虚拟机外部观察和分析即时编译的数据和结果,以及几种常见的编译期优化技术 📜 部分五: 高效并发(第12~13章) 第12章: 虚拟机Java内存模型的结构及操作,以及原子性、可见性和有序性,先行发生原则的规则及使用,以及线程在Java语言中的实现,以及Java中的协程的相关内容 第13章: 线程安全涉及的概念和分类、同步实现的方式及虚拟机的底层运作原理,虚拟机实现高效并发所做的一系列锁优化措施 第1章: 走进Java 1.1 Java简介 Java 存在的优点: 结构严谨、面向对象的编程语言 摆脱了硬件平台的束缚 提供了相对安全的内存管理和访问机制,避免了绝大部分内存泄漏和指针越界问题 热点代码检测和运行时编译及优化 完善的应用程序接口,极大的提升了软件的开发效率 1.2 Java技术体系 JCP官方(Java Community Process,Java社区)定义的Java技术体系包括: Java程序涉及语言 各种硬件平台上的Java虚拟机实现 Class文件格式 Java类库API 来自商业机构和开源社区的第三方Java类库 根据Java各个组成部分的功能来进行划分: JDK(Java Development Kit): Java虚拟机、Java类库、Java程序设计语言; 支持Java程序开发的最小环境 JRE(Java Runtime Environment): Java类库API中的Java SE API子集、Java虚拟机; 支持Java程序运行的标准环境 JDK和JRE范围图示: 根据技术关注的重点业务来划分: Java Card: 支持Java小程序(Applets)运行在小内存设备上的平台 Java ME(Micro Edition): 支持Java程序运行在移动终端(手机、PDA)上的平台,对Java API有所精简,并加入了移动端的针对性支持. 智能手机中主要使用Java语言开发程序的Android并不属于Java ME Java SE(Standard Edition): 支持面向桌面级应用(如Windows下的应用程序)的Java平台,提供了完整的Java核心API Java EE(Enterprise Edition): 支持使用多层架构的企业应用(如ERP、MIS、CRM应用)的Java平台,除了提供Java SE API外,还对其做了大量有针对性的扩充,提供相关部署支持 1.3 Java发展历程 略 1.4 Java虚拟机家族 1.4.1 Sun Classic/Exact VM 🔖 Sun Classic: 世界上第一款商用Java虚拟机 Classic VM只能使用纯解释器方式来执行Java代码，要想使用即时编译器就需要外挂；但如果外挂了即时编译器，那么它就会接管虚拟机的执行系统，使得解释器无法工作 JDK1.2之前，Sun提供的外挂编译器为sunwjit（Sun Workshop JIT），除此之外，类似的外挂编辑器还有Symantec JIT和shuJIT等 JDK1.2时，曾在Solaris平台上发布过一款名为Exact VM的虚拟机，它的编译执行系统已经具备现代高性能虚拟机雏形，如热点探测、两级即时编译器、编译器与解释器混合工作模式等 Exact VM使用准确式内存管理（Exact Memory Management，也称为Non-Con-Servative/Accurate Memory Management），准确式内存管理是指虚拟机可以知道内存中某个位置的数据具体是什么类型 JDK1.3时，HotSpot VM成为默认虚拟机，Classic VM成为备用选择 JDK1.4时，Classic VM才完全退出商用虚拟机的历史舞台，与Exact VM一起进入了 Sun Labs Research VM之中 1.4.2 HotSpot VM ","link":"https://stag1129.github.io/note/Java虚拟机与Java高级特性/"},{"title":"Redis数据库","content":"📖 内容介绍：Redis是一种NoSQL数据库 数百万开发人员用作数据库、缓存、流式处理引擎和消息代理的开源内存中数据存储 第一章 NoSQL相关概念 1.1 NoSQL特点及优势 🔖 NoSQL全称是Not Only SQL，是一种非关系型数据库 相较于传统的SQL数据库而言，NoSQL特点： 不保证关系数据ACID特性 - ACID：原子性(atomicity，或称不可分割性)、 一致性 (consistency)、 隔离性 (isolation，又称独立性)、 持久性 (durabilit) 并不遵循SQL标准 消除数据之前关联特性 相较于传统的SQL数据库而言，NoSQL优势： 远超传统关系型数据库的性能 非常易于扩展 数据模型更加灵活 高可用 1.2 NoSQL种类 🔖 Redis数据库是一个开源的键值存储数据库，所有的数据全部存放在内存中，它的性能大大高于磁盘IO，并且它也可以支持数据持久化，支持横向扩展,主从复制等 NoSQL数据库的种类: 键值存储数据库: 所有数据都是通过键值方式存储的,类似于HashMap,使用起来非常简单方便,性能也非常高 列存储数据库: 通常用来应对分布式存储的海量数据.键仍然存在,但是它们的特点是指向了多个列 文档型数据库: 它是以一种特定的文档格式存储数据,比如JSON格式,在处理网页等复杂的数据时,文档型数据库比传统键值数据库的查询效率更高 图形数据库: 利用类似于图的数据结构存储数据,结合图相关算法高速访问 第二章 Redis安装和部署 🔗 Redis下载地址： 官网地址：https://redis.io/download/ Windows版本：https://github.com/tporadowski/redis/releases 2.1 在CentOS下安装Redis 下载Redis安装包 wget https://github.com/redis/redis/archive/7.0.7.tar.gz 解压Redis安装包 tar -zxvf 7.0.7.tar.gz 进入Reids目录并编译 cd ./7.0.7 &amp;&amp; make 安装Redis make install 2.2 在Windows下安装Redis 下载Redis安装包 下载地址: https://github.com/tporadowski/redis/releases/download/v5.0.14.1/Redis-x64-5.0.14.1.zip 解压Redis的ZIP包 Redis-x64-5.0.14.1.zip -&gt; Redis-x64-5.0.14.1文件夹 2.3 常见问题 提示没有安装GCC 解决方法: yum install gcc 问题截图: 提示没有找到目录 解决办法: make MALLOC=libc 问题截图: 第三章 基本操作 (HashMap&lt;String,String&gt;) 🔖 Redis数据库是有一个整数索引标识.默认情况下,Redis数据库使用0号数据库,通过Redis配置文件中的参数来修改数据库总数,默认共16个 切换Redis数据库 select 数据库索引标识 添加数据 添加一个数据: set &lt;key&gt; &lt;value&gt; 添加多个数据: mset [&lt;key&gt; &lt;value&gt;]... 所有存储的数据默认会以字符串进行保存,可以通过 : 进行板块分割 set A:key1:key2 value 获取存入的键值 get &lt;key&gt; 存储数据时,设定数据过期时间,默认永久有效(-1) 设置过期秒数: set &lt;key&gt; &lt;value&gt; EX 秒数 设置过期毫秒数: set &lt;key&gt; &lt;value&gt; PX 毫秒 单独设定数据过期时间 expire &lt;key&gt; 秒数 查看某个键值对的剩余有效时间 剩余有效秒数: ttl &lt;key&gt; 剩余有效毫秒数: pttl &lt;key&gt; 设置某个键值对永久有效 persist &lt;key&gt; 删除键值对 del &lt;key&gt; [&lt;key&gt;]... 查看所有的键 keys * 查看某个键是否存在(存在返回1;不存在返回0) exists &lt;key&gt; 随机取键 randomkey 将当前数据库的值移动到另一个数据库 move &lt;key&gt; 整数索引标识 修改键的名称 直接修改: rename &lt;key&gt; &lt;新名称&gt; 先判断新名称,不存在时修改: renamex &lt;key&gt; &lt;新名称&gt; 对值为整数类型的数据可进行自增自减操作 自增1: incr &lt;key&gt; 自增n: incrby &lt;key&gt; n 自减1: decr &lt;key&gt; 查看值的数据类型 type &lt;key&gt; 第四章 其他数据类型 4.1 Hash数据(HashMap&lt;String,HashMap&lt;String,String&gt;&gt;) 添加数据 hset &lt;key&gt; [&lt;字段&gt; &lt;值&gt;]... 获取值 获取某个字段值: hget &lt;key&gt; &lt;字段&gt; 获取全部字段和值: hgetall &lt;key&gt; 判断字段是否存在(存在返回1;不存在返回0) hexists &lt;key&gt; &lt;字段&gt; 删除字段(删除成功为1;删除失败为0) hdel &lt;key&gt; &lt;字段&gt; 获取hash中存储键值对的个数 hlen &lt;key&gt; 一次性获取所有的字段值 hvals &lt;key&gt; 一次性获取所有的字段 hkeys &lt;key&gt; 4.2 List数据(LinkedList) 添加元素 头部添加元素：lpush &lt;key&gt; &lt;element&gt;... 尾部添加元素：rpush &lt;key&gt; &lt;element&gt;... 指定位置前后添加元素：linsert &lt;key&gt; before/after &lt;指定元素&gt; &lt;element&gt; 获取元素 通过下表获取元素：lindex &lt;key&gt; &lt;下标&gt; 获取并移除头部元素：lpop &lt;key&gt; 获取并移除尾部元素：rpop &lt;key&gt; 获取制定范围内的元素(负数为从后往前)：lrange &lt;key&gt; start stop 获取某个键的全部元素：lrange &lt;key&gt; 0 -1 从当前数组中的右侧获取一个数插入到目标数组的左侧 rpoplpush 当前数组 目标数组 阻塞操作,等待数据产生 blpop &lt;key&gt;... timeout 4.3 Set数据(HashSet) 添加数据 sadd &lt;key&gt; &lt;value&gt;... 查看数据个数 scard &lt;key&gt; 判断集合中是否包含某个值 sismember &lt;key&gt; &lt;value&gt; 列出所有值 smembers &lt;key&gt; 集合之间的运算 集合之间的差集：sdiff &lt;key1&gt; &lt;key2&gt; 集合之间的交集：sinter &lt;key1&gt; &lt;key2&gt; 集合之间并集：sunion &lt;key1&gt; &lt;key2&gt; 将集合之间的差集存到目标集合中：sdiffstore 目标 &lt;key1&gt; &lt;key2&gt; 将集合之间的交集存到目标集合中：sinterstore 目标 &lt;key1&gt; &lt;key2&gt; 将集合之间的并集存到目标集合中：sunionstore 目标 &lt;key1&gt; &lt;key2&gt; 移动制定值到另一个集合中 smove &lt;key&gt; 目标 &lt;value&gt; 删除数据 随机移除一个数据：spop &lt;key&gt; 移除指定值：srem &lt;key&gt; &lt;value&gt; 4.4 SortedSet数据 添加带分数的值 zadd &lt;key&gt; [&lt;score&gt; &lt;value&gt;]... 查询有多少个值 zcard &lt;key&gt; 移除特定的值 zrem &lt;key&gt; &lt;value&gt;... 获取区间内的值 zrange &lt;key&gt; start stop 根据值的分数来获取 通过分数值查看：zrangebyscore &lt;key&gt; start stop [withscores] [limit] 统计某个分数值内的数量：zcount &lt;key&gt; start stop 根据分数获取指定排名：zrank &lt;key&gt; &lt;value&gt; 4.5 其他数据 Bitmap: 位图操作 HyperLogLong: 做基数统计 Geospatial: 地理空间以及索引半径查询 📑 常用命令参考：https://zhuanlan.zhihu.com/p/47692277 第五章 Redis持久化 🔖 持久化实现方式有两种方案： 直接保存当前已经存储的数据,相当于复制内存中的数据到磁盘上,需要恢复数据时直接读取即可 保存存放数据的所有过程,只需要将整个过程完整地重演一遍就能保证与之前数据库中的内容一致 5.1 RDB（保存已经存储的数据） 方式一：在Redis主进程中开启保存事物：save 方式二：单独开一个子进程后台执行保存：bgsave 执行后会产生一个dump.rdb文件,文件中的数据就保存了内存中存放的数据,当服务重启后,会自动加载里面的内容到对应的数据库中 修改配置文件的配置信息：save 300 10 # 300秒内有10个写入 5.2 AOF(存放数据的所有过程信息) 通过日志的形式每次执行的命令都进行保存,服务器重启时会将所有命令一次执行 AOF写日志的策略： always: 每次执行写操作都会保存一次 everysec: 每秒保存一次(默认配置) no: 系统自定义 AOF通过配置文件开启，将appendonly的no改为yes：appendonly yes AOF配置文件调整策略：appendfsync always | everysec | no 重启服务后,可以看到服务器目录下多了一个appendonly.aof文件,存储的就是我们执行的命令 手动执行重写操作：bgrewriteaof 配置文件中配置自动重写: 百分比计算：auto-aof-rewrite-percentage 100 当达到这个大小时,触发自动重写：auto-aof-rewrite-min-size 64mb 5.3 RDB和AOF对比 AOF: 优点: 存储速度快,消耗资源少、支持实时存储 缺点: 加载数据慢、数据体积大 RDB: 优点: 加载速度快、数据体积小 缺点: 存储速度慢,大量消耗资源、会发生数据丢失 第六章 事物和锁机制 6.1 事物 🔖 保证多条命令一次性完整执行而中途不受到其他命令干扰 开启事物：multi 执行事物：exec 取消事物：discard 6.2 锁机制 悲观锁: 时刻认为别人回来抢占资源,禁止一切外来访问,直到释放锁,具有强烈的排他性质 乐观锁: 并不认为会有其他人来抢占资源,所以会直接对数据进行操作,在操作时再去验证是否会有其他人抢占资源 监视某个目标,如果执行事务之前被监视的目标发生了修改,则取消本次事物：watch 取消监视：unwatch 第七章 Redis与应用程序交互 7.1 在Maven中调用Redis pom文件中引入Redis依赖&lt;!--Jedis - Redis的依赖库--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--slf4j - 解决Jedis运行时提示的问题org.slf4j.impl.StaticLoggerBinder--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt; &lt;version&gt;1.7.32&lt;/version&gt; &lt;/dependency&gt; 测试是否连接成功public static void main(String[] args) { Jedis jedis = new Jedis(&quot;localhost&quot;, 6379); jedis.close(); } 举例1：通过jedis设置并查询普通键值对(HashMap&lt;String,String&gt;)public static void main(String[] args) { try (Jedis jedis = new Jedis(&quot;localhost&quot;, 6379)) { jedis.set(&quot;a&quot;, &quot;123&quot;); System.out.println(jedis.get(&quot;a&quot;)); } } 举例2：通过jedis设置并查询Hash数据(HashMap&lt;String,HashMap&lt;String,String&gt;&gt;)public static void main(String[] args) { try (Jedis jedis = new Jedis(&quot;localhost&quot;, 6379)) { jedis.hset(&quot;b&quot;, &quot;name&quot;, &quot;张三&quot;); Map&lt;String, String&gt; temp = new HashMap&lt;&gt;(); temp.put(&quot;age&quot;, &quot;19&quot;); jedis.hset(&quot;b&quot;, temp); jedis.hgetAll(&quot;b&quot;).forEach((key, value) -&gt; { System.out.println(key + &quot; : &quot; + value); }); } } 举例3：通过jedis设置并查询List数据(LinkedLIst)public static void main(String[] args) { try (Jedis jedis = new Jedis(&quot;localhost&quot;, 6379)) { jedis.lpush(&quot;c&quot;, &quot;123&quot;, &quot;456&quot;, &quot;789&quot;); jedis.lrange(&quot;c&quot;, 0, -1).forEach(System.out::println); } } 举例4：通过jedis设置并查询Set数据(HashSet)public static void main(String[] args) { try (Jedis jedis = new Jedis(&quot;localhost&quot;, 6379)) { jedis.sadd(&quot;d&quot;, &quot;123&quot;, &quot;123&quot;, &quot;456&quot;, &quot;789&quot;); jedis.smembers(&quot;d&quot;).forEach(System.out::println); } } 举例5：通过jedis设置并查询SortedSet数据public static void main(String[] args) { try (Jedis jedis = new Jedis(&quot;localhost&quot;, 6379)) { jedis.zadd(&quot;e&quot;, 5, &quot;abc&quot;); jedis.zadd(&quot;e&quot;, 10, &quot;def&quot;); jedis.zadd(&quot;e&quot;, 2, &quot;hij&quot;); jedis.zrange(&quot;e&quot;, 0, -1).forEach(System.out::println); } } 7.2 在SpringBoot中调用Redis 创建SpringBoot勾选Lombok和Redis相关依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 在application.yml中配置redis相关信息spring: redis: host: localhost port: 6379 database: 0 SpringBoot自动创建Redis两种模板Bean(RedisAutoConfiguration.java)@Bean @ConditionalOnMissingBean( name = {&quot;redisTemplate&quot;} ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) { return new StringRedisTemplate(redisConnectionFactory); } 举例1：通过StringRedisTemplate设置并查询普通键值对(HashMap&lt;String,String&gt;)@Autowired private StringRedisTemplate template; @Test void test1() { template.opsForValue().set(&quot;a&quot;, &quot;lisi&quot;); System.out.println(template.opsForValue().get(&quot;a&quot;)); } 举例2：通过StringRedisTemplate删除并判断是否存在普通键值对(HashMap&lt;String,String&gt;)template.delete(&quot;a&quot;); template.hasKey(&quot;a&quot;); 7.3 在SpringBoot中Redis事物管理器 🔖 Spring没有专门的Redis事物管理器，所以只能借助于JDBC提供的 在pom文件中引入JDBC依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt; &lt;/dependency&gt; 在application.yml中配置MySQL数据库信息spring: datasource: url: jdbc:mysql://localhost:3306/demo?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 创建RedisService,并开启Redis事物@Service public class RedisService { @Autowired private StringRedisTemplate template; @PostConstruct public void init() { template.setEnableTransactionSupport(true); } @Transactional public void test() { template.multi(); template.opsForValue().set(&quot;a&quot;, &quot;wangwu&quot;); template.exec(); } } 调用RedisService的test方法@Autowired RedisService redisService; @Test void test1() { redisService.test(); } 7.4 在SpringBoot中Redis序列化 JDK自带的序列化器 创建Demo实体类@Data @AllArgsConstructor @NoArgsConstructor public class Demo implements Serializable { String id; String name; } 通过RedisTemplate调用@Autowired private RedisTemplate&lt;Object, Object&gt; template; @Test void test1() { StringRedisSerializer StringRedisSerializer=new StringRedisSerializer(); template.setKeySerializer(StringRedisSerializer); Demo demo = new Demo(&quot;1&quot;, &quot;zhangsan&quot;); template.opsForValue().set(&quot;e&quot;, demo); } Jackson序列化器 创建Demo实体类 @Data @AllArgsConstructor @NoArgsConstructor public class Demo { String id; String name; } 在pom文件中引入jackson-databind依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; 通过RedisTemplate调用 @Autowired private RedisTemplate&lt;Object, Object&gt; template; @Test void test1() { StringRedisSerializer StringRedisSerializer=new StringRedisSerializer(); template.setKeySerializer(StringRedisSerializer); template.setValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class)); Demo demo = new Demo(&quot;1&quot;, &quot;zhangsan&quot;); template.opsForValue().set(&quot;e&quot;, demo); } ","link":"https://stag1129.github.io/note/Redis数据库/"}]}